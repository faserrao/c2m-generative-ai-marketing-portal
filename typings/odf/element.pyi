"""
This type stub file was generated by pyright.
"""

import sys
import xml.dom
from xml.dom.minicompat import *

if sys.version_info[0] == 3:
    unicode = str
    unichr = ...
_xml11_illegal_ranges = ...
_xml10_illegal_ranges = ...
_xml_discouraged_ranges = ...
if sys.maxunicode >= 65536:
    _xml_discouraged_ranges = ...
_xml_filtered_chars_re = ...
class IllegalChild(Exception):
    """ Complains if you add an element to a parent where it is not allowed """
    ...


class IllegalText(Exception):
    """ Complains if you add text or cdata to an element where it is not allowed """
    ...


class Node(xml.dom.Node):
    """ super class for more specific nodes """
    parentNode = ...
    nextSibling = ...
    previousSibling = ...
    def hasChildNodes(self):
        """ Tells whether this element has any children; text nodes,
            subelements, whatever.
        """
        ...
    
    def insertBefore(self, newChild, refChild):
        """ Inserts the node newChild before the existing child node refChild.
            If refChild is null, insert newChild at the end of the list of children.
        """
        ...
    
    def appendChild(self, newChild):
        """ Adds the node newChild to the end of the list of children of this node.
            If the newChild is already in the tree, it is first removed.
        """
        ...
    
    def removeChild(self, oldChild):
        """ Removes the child node indicated by oldChild from the list of children, and returns it.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __unicode__(self):
        ...
    


class Childless:
    """ Mixin that makes childless-ness easy to implement and avoids
        the complexity of the Node methods that deal with children.
    """
    attributes = ...
    childNodes = ...
    firstChild = ...
    lastChild = ...
    def appendChild(self, node):
        """ Raises an error """
        ...
    
    def hasChildNodes(self):
        ...
    
    def insertBefore(self, newChild, refChild):
        """ Raises an error """
        ...
    
    def removeChild(self, oldChild):
        """ Raises an error """
        ...
    
    def replaceChild(self, newChild, oldChild):
        """ Raises an error """
        ...
    


class Text(Childless, Node):
    nodeType = ...
    tagName = ...
    def __init__(self, data) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __unicode__(self):
        ...
    
    def toXml(self, level, f):
        """ Write XML in UTF-8 """
        ...
    


class CDATASection(Text, Childless):
    nodeType = ...
    def toXml(self, level, f):
        """ Generate XML output of the node. If the text contains "]]>", then
            escape it by going out of CDATA mode (]]>), then write the string
            and then go into CDATA mode again. (<![CDATA[)
        """
        ...
    


class Element(Node):
    """ Creates a arbitrary element and is intended to be subclassed not used on its own.
        This element is the base of every element it defines a class which resembles
        a xml-element. The main advantage of this kind of implementation is that you don't
        have to create a toXML method for every different object. Every element
        consists of an attribute, optional subelements, optional text and optional cdata.
    """
    nodeType = ...
    namespaces = ...
    _child_node_types = ...
    def __init__(self, attributes=..., text=..., cdata=..., qname=..., qattributes=..., check_grammar=..., **args) -> None:
        ...
    
    def get_knownns(self, prefix):
        """ Odfpy maintains a list of known namespaces. In some cases a prefix is used, and
            we need to know which namespace it resolves to.
        """
        ...
    
    def get_nsprefix(self, namespace):
        """ Odfpy maintains a list of known namespaces. In some cases we have a namespace URL,
            and needs to look up or assign the prefix for it.
        """
        ...
    
    def allowed_attributes(self):
        ...
    
    def addElement(self, element, check_grammar=...):
        """ adds an element to an Element

            Element.addElement(Element)
        """
        ...
    
    def addText(self, text, check_grammar=...):
        """ Adds text to an element
            Setting check_grammar=False turns off grammar checking
        """
        ...
    
    def addCDATA(self, cdata, check_grammar=...):
        """ Adds CDATA to an element
            Setting check_grammar=False turns off grammar checking
        """
        ...
    
    def removeAttribute(self, attr, check_grammar=...):
        """ Removes an attribute by name. """
        ...
    
    def setAttribute(self, attr, value, check_grammar=...):
        """ Add an attribute to the element
            This is sort of a convenience method. All attributes in ODF have
            namespaces. The library knows what attributes are legal and then allows
            the user to provide the attribute as a keyword argument and the
            library will add the correct namespace.
            Must overwrite, If attribute already exists.
        """
        ...
    
    def setAttrNS(self, namespace, localpart, value):
        """ Add an attribute to the element
            In case you need to add an attribute the library doesn't know about
            then you must provide the full qualified name
            It will not check that the attribute is legal according to the schema.
            Must overwrite, If attribute already exists.
        """
        ...
    
    def getAttrNS(self, namespace, localpart):
        """
        gets an attribute, given a namespace and a key
        @param namespace a unicode string or a bytes: the namespace
        @param localpart a unicode string or a bytes:
        the key to get the attribute
        @return an attribute as a unicode string or a bytes: if both paramters
        are byte strings, it will be a bytes; if both attributes are
        unicode strings, it will be a unicode string
        """
        ...
    
    def removeAttrNS(self, namespace, localpart):
        ...
    
    def getAttribute(self, attr):
        """ Get an attribute value. The method knows which namespace the attribute is in
        """
        ...
    
    def write_open_tag(self, level, f):
        ...
    
    def write_close_tag(self, level, f):
        ...
    
    def toXml(self, level, f):
        """
        Generate an XML stream out of the tree structure
        @param level integer: level in the XML tree; zero at root of the tree
        @param f an open writable file able to accept unicode strings
        """
        ...
    
    def getElementsByType(self, element):
        """ Gets elements based on the type, which is function from text.py, draw.py etc. """
        ...
    
    def isInstanceOf(self, element):
        """ This is a check to see if the object is an instance of a type """
        ...
    


